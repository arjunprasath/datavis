WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:07.310
&gt;&gt; PARLANTE: Back to pie quick Python class.
So, the -- so, this morning I'm going to talk

00:00:07.310 --> 00:00:13.110
about regular expression a little bit, in
particular, regular expressions in Python.

00:00:13.110 --> 00:00:17.050
You may or may not know regular expressions
before hand. That's okay. And I'm not going

00:00:17.050 --> 00:00:20.480
to show you all of regular expressions. I
will show you, like, just enough for us to

00:00:20.480 --> 00:00:24.280
get some useful stuff on. But regular expressions
are a very powerful combination with Python.

00:00:24.280 --> 00:00:28.470
There's a nice integration and so on. I will
show you that. Also, the exercises later today

00:00:28.470 --> 00:00:33.410
will, of course, you know, have little elements
which are solved nicely with Python regular

00:00:33.410 --> 00:00:38.810
expressions. Just as a--regular expressions
are sort of a good news, bad news situation.

00:00:38.810 --> 00:00:45.360
They--regular expressions are very--I mean,
I could use the word powerful but also, like,

00:00:45.360 --> 00:00:49.150
I could use the word very dense. Like, if
you sort of measured the amount of thought

00:00:49.150 --> 00:00:54.360
and cups of coffee that get poured into, like,
per character, like the regular expressions

00:00:54.360 --> 00:00:58.520
are, like, the most dense language possibly.
You could possible for hours over, like, one

00:00:58.520 --> 00:01:02.829
line of text trying to get, like, all the
pats and backticks, and whatever crack. We're

00:01:02.829 --> 00:01:05.759
not going to get into that scary [INDISTINCT]
but they are--we're going to sort of touch

00:01:05.759 --> 00:01:11.159
into a little bit of that part. So, one word
of warning, when messing with regular expressions,

00:01:11.159 --> 00:01:15.990
it's the--I tend--I try to move a little slowly,
like, they are very powerful, they are a little

00:01:15.990 --> 00:01:19.420
tricky, so I'm going to try to be careful.
And for, you know, today's discussion, like,

00:01:19.420 --> 00:01:23.899
yeah, I'm going to show you just sort of basic
stuff. And if you're extremely familiar with

00:01:23.899 --> 00:01:24.899
regular expressions, well, you know, just
bear with me for a little bit. We're not going

00:01:24.899 --> 00:01:30.530
to do this for too long. And, obviously, really
I'm going to emphasize on Python. That's the

00:01:30.530 --> 00:01:36.060
bad news. The good news is also on all the
exercises we're going to do later today, in

00:01:36.060 --> 00:01:40.920
case I forget to mentions, if there is a regular
expression component at the very end printed

00:01:40.920 --> 00:01:45.921
in little tiny print, I put the what the regular
expression solution is. So, it's kind of like

00:01:45.921 --> 00:01:48.639
you can sort of flip to the back and get the
answer if you get--if you're struggling with

00:01:48.639 --> 00:01:52.109
that part of it, because really, you know,
it is a Python class. So, I don't want you

00:01:52.109 --> 00:01:54.840
to block on regular expressions too much.
All right, so with that introduction, let

00:01:54.840 --> 00:02:01.959
me--I'm going to start talking about how these
things work. But first, I have to tell you

00:02:01.959 --> 00:02:08.420
a joke which [INDISTINCT]. What do you call
a pig with three eyes? Piiig. All right, now,

00:02:08.420 --> 00:02:14.080
that will be covered. The necessity, that
will become clear a little bit. So let me

00:02:14.080 --> 00:02:21.580
fire up the interpreter here. So, regular
expressions in Python are supported by a module

00:02:21.580 --> 00:02:26.090
called "re." So, I'm just going to import
that. I'm going to do a lot of stuff here

00:02:26.090 --> 00:02:31.200
in the interpreter. I'm going to sort of build
this up. So, the basic idea with regular expressions

00:02:31.200 --> 00:02:36.830
is their way of searching for a pattern inside
of a larger text. So very much like, you know,

00:02:36.830 --> 00:02:40.360
search in Microsoft Word where you have the
little pattern you're looking for, and it's

00:02:40.360 --> 00:02:44.220
going to look over this huge text and find
the first instance of that pattern. But it's

00:02:44.220 --> 00:02:48.450
this whole language where the patterns can
be very popular. So the way this works in

00:02:48.450 --> 00:02:57.060
Python the simplest way is there is a function
inside of re called "search." And I'll sort

00:02:57.060 --> 00:03:03.060
of spec this out. It's going to work basically
this way where the first argument to search

00:03:03.060 --> 00:03:06.480
is the pattern, which I'm going to about a
lot, the second argument is just kind of whatever

00:03:06.480 --> 00:03:13.330
the text I want to search. And what it returns
is actually not a Boolean, not text, but a

00:03:13.330 --> 00:03:18.660
match object. So, here, I'll write this as
"match." And then the match object will indicate--it

00:03:18.660 --> 00:03:25.510
will show us a bunch of things about the found
text. So, let me do an example. So, for the

00:03:25.510 --> 00:03:32.780
text, I'll use our punch line. We'll say,
you know, it's called piiig. All right, and

00:03:32.780 --> 00:03:38.610
let's say for the pattern, we're looking for--and
we'll just search--start talking about patterns

00:03:38.610 --> 00:03:47.610
here. Maybe I'll just look for "iiig." I'll
just put the simplest possible case. So, I

00:03:47.610 --> 00:03:53.230
run it. Now, it returns this match object.
So, for this type, match--I mean, it's not

00:03:53.230 --> 00:03:58.520
really going to print, but it will say, well,
that's, you know, that's some kind of Python

00:03:58.520 --> 00:04:02.790
object. So it turns out for the first 20 minutes
this morning, the only thing you need to know

00:04:02.790 --> 00:04:08.120
about match is that it has this--it responds
to this method called "group." If called group

00:04:08.120 --> 00:04:15.490
on it, it says, it shows you here is what
the matching text was. So, this is our first

00:04:15.490 --> 00:04:19.410
example of the regular expression. And the
simplest case in a regular expression is,

00:04:19.410 --> 00:04:25.850
like iig here, is that a character like I
or G or something like that matches itself.

00:04:25.850 --> 00:04:29.300
So the lower case I matches the lower case
I. Now, I'm going to build up the vocabulary

00:04:29.300 --> 00:04:33.320
to have a lot more complicated matches. But
that's just characters matching themselves

00:04:33.320 --> 00:04:38.030
is the simplest case. All right, another thing
to point out here. So, this match was successful.

00:04:38.030 --> 00:04:42.800
Now, I'm going to do one that's not successful.
So, like what, say, we're looking for the

00:04:42.800 --> 00:04:49.150
pattern "igs" and that pattern just doesn't
appear in there. So, if I run that and I look

00:04:49.150 --> 00:04:54.280
at the match object, it's none. If the interpreter
is none, it just prints us nothing. But--it's

00:04:54.280 --> 00:05:00.770
just not there. So, if I were to try and say,
oh, "match.group," it's a very common error,

00:05:00.770 --> 00:05:04.300
it's not going to work. Like, because match
doesn't point to an object that has a group

00:05:04.300 --> 00:05:11.340
behavior. It just match the points to nothing.
So, the absolutely standard way to use re.search

00:05:11.340 --> 00:05:15.940
is--I'll sort of do an interpreter--first
you do re.search and then the next line is

00:05:15.940 --> 00:05:20.630
something like "if match:." Like, if the match
is there, then we found it. We can look at

00:05:20.630 --> 00:05:24.639
the group. Otherwise, it's not there. Now,
what I'm going to do--I'm actually going to

00:05:24.639 --> 00:05:28.370
write--just--I'm going to def a little find
function just here in the interpreter. I'm

00:05:28.370 --> 00:05:30.600
going to do so many regular expression searches
today. I just want to encapsulate that behavior.

00:05:30.600 --> 00:05:35.190
So that what I'm going to show you here are
some of the prototypical use of re.search

00:05:35.190 --> 00:05:38.210
and then I'll just use it for half an hour.
So I'm going to say--I'm just going to call

00:05:38.210 --> 00:05:42.810
this thing a "find" and it will take a pattern
and some text. This is a little weird. I'm

00:05:42.810 --> 00:05:46.770
doing this in the interpreter, but this works.
I'm going to type a colon and I hit return,

00:05:46.770 --> 00:05:50.810
and now the interpreter is saying, "Okay,
what's the next line?" And so, I'll say space,

00:05:50.810 --> 00:05:58.500
space and I'll say if match. Now, I'm relying
on the fact that--I talked a little about

00:05:58.500 --> 00:06:01.950
this yesterday, the rules for true and false.
Now, there's a bunch of things that kind of

00:06:01.950 --> 00:06:06.930
count as false: zero counts as false, the
empty string counts as false. It happens that

00:06:06.930 --> 00:06:10.910
the value none also counts as false. So, what
this if statement is sort of saying is, like,

00:06:10.910 --> 00:06:17.280
yeah, if that match is not none essentially.
If it's there, it searches, too. So, if match

00:06:17.280 --> 00:06:25.700
is there, I'm going to say "print match.group."
Okay, return again, two spaces, I'll say otherwise--I

00:06:25.700 --> 00:06:29.900
want to say what happens. So, essentially,
yeah, not found. All right, those are the

00:06:29.900 --> 00:06:37.730
two cases. The question is you always need
the .group. I'm going to always use it today.

00:06:37.730 --> 00:06:42.460
In reality, the match object has--you could
read the dots what--it has, you know, in what

00:06:42.460 --> 00:06:45.500
character position did it start, where is
that, and all sorts kind of other stuff about

00:06:45.500 --> 00:06:48.460
the match you might want to know and sort
of composite in there. All right, I'm going

00:06:48.460 --> 00:06:54.180
to--here, return. All right, so now I have
to find my find function, so now I can sort

00:06:54.180 --> 00:06:58.360
of use this for--well, I'll just--I'll use
it for my earlier example. So, now, if I say

00:06:58.360 --> 00:07:16.360
find on that, I get "not found." And if I
say ig--why didn't that work? I did what?

00:07:16.360 --> 00:07:26.500
Oh, I didn't do the match function. Yeah,
you're right. All right. All right, here,

00:07:26.500 --> 00:07:30.540
I'll just do it really quickly. So, there's
def and then I'll say "match = re.search."

00:07:30.540 --> 00:07:37.130
Oh, sure. Now, you guys tell me. Sure, where
were you five minutes ago? Okay. So, there

00:07:37.130 --> 00:07:41.330
is the match and I say "if match:," well,
okay, everyone is going to know this code

00:07:41.330 --> 00:07:53.830
by heart. If match print "match.group", else:
print not found. Okay. So, now, what will

00:07:53.830 --> 00:08:00.060
we say, this time for sure--excellent. Okay.
So, now, I'm just going to do--you know, I'm

00:08:00.060 --> 00:08:05.830
going to build the vocabulary of regular expressions.
So, the simplest rule, rule number one is

00:08:05.830 --> 00:08:11.020
that simple characters just match themselves.
Rule number two is that--and I'm actually

00:08:11.020 --> 00:08:16.800
going to--a little hi-tech here. I'm going
to make a little space. Special characters,

00:08:16.800 --> 00:08:22.350
I made a little table up here. The dot, they
are special, dot matches any character, it

00:08:22.350 --> 00:08:29.990
means anything except it does not match anyone.
So, I could have said, "Well, I'm looking

00:08:29.990 --> 00:08:37.070
for, let's say, any three characters and then
a G." That's the pattern I'm looking for.

00:08:37.070 --> 00:08:41.760
And so, in this case, that's going to find
pig. So can be, you know, a little bit of

00:08:41.760 --> 00:08:45.450
a sense of, like, how this is going to be,
you know, more powerful than just regular

00:08:45.450 --> 00:08:55.630
Microsoft Word search. So, the--another route
is going on here is--so, for example, if I

00:08:55.630 --> 00:09:01.860
were to say "...G," you know--or I don't know,
X. There. It's not going to find that. Well,

00:09:01.860 --> 00:09:06.820
maybe I'll do it the way I did it before to
make it better, put the S. So, if I say "...gs,"

00:09:06.820 --> 00:09:14.640
that's not found. There's an all the way symmetry
here where in order to succeed, all of the

00:09:14.640 --> 00:09:19.720
pattern must match. So, in this case, I've
got four characters or whatever all--you know,

00:09:19.720 --> 00:09:22.980
I can't say, like, "Oh, well, three out of
four," no. A hundred percent of the pattern

00:09:22.980 --> 00:09:26.770
has to be kind of consumed and matched, but
that's not true about the text, right? In

00:09:26.770 --> 00:09:30.180
all of my examples, I'm not matching the whole
text. Whatever, I can use a little bit of

00:09:30.180 --> 00:09:35.040
this at the end of this word or whatever,
so as to say, a fundamental asymmetry. The

00:09:35.040 --> 00:09:38.649
other thing that's going to happen here is
that the search is going to go to left to

00:09:38.649 --> 00:09:42.910
right, and it's going to--it's satisfied as
soon as it finds a solution. So, we could

00:09:42.910 --> 00:09:49.680
make a case whether it's maybe--say for example
I'm looking for "...g" and then I here like--and

00:09:49.680 --> 00:09:53.680
then I'll make this like, "Oh-oh, there's
a much better solution." You know, this one

00:09:53.680 --> 00:09:59.649
is eg. What's going to happen is it's not
finding that second one, right? It's not just

00:09:59.649 --> 00:10:05.270
getting into it. But, how can I make it find
that one? What if I said, "Well, really what

00:10:05.270 --> 00:10:13.170
I'm looking for is an X and then two characters
I don't know about, and then the G. So then,

00:10:13.170 --> 00:10:16.770
it's like passes over the first one and finds
the second one. Now, the regular expression

00:10:16.770 --> 00:10:20.770
engine, I'm not getting too much detail, is--you
know, I mean, it finds all the things it's

00:10:20.770 --> 00:10:26.520
supposed to and it's smart. It understands.
It does--it will backtrack. So, for example--this

00:10:26.520 --> 00:10:33.540
is--what if I said, well, I'm looking for
"...g" and then I insist that there's an S.

00:10:33.540 --> 00:10:37.860
And here, I'll go fix this one. It's like
kind of an S here. So you can imagine--so

00:10:37.860 --> 00:10:42.709
that exceeds. So you can imagine it like it
may be sort of tries to make this one work

00:10:42.709 --> 00:10:47.080
and it doesn't work, and so it said, "Well,
it didn't work." It will keep going. So, the

00:10:47.080 --> 00:10:53.649
other thing is it is going--it is left to
right. So, it finds the first one. Okay, yes.

00:10:53.649 --> 00:10:57.370
So the question is why didn't I meet the first
one. The trick here is I added an S to the

00:10:57.370 --> 00:11:02.100
end of the pattern. If you read the pattern,
it says--that says, any character, any character

00:11:02.100 --> 00:11:12.810
gs. And the problem is it could--this one?
One more, this one. That will succeed it.

00:11:12.810 --> 00:11:21.300
Oh, why didn't I find that? Okay, yeah. So
what it does is it--sorry, yeah--it goes left

00:11:21.300 --> 00:11:25.720
to right. And once it finds a solution, it's
like, "Okay, I'm done. Don't try it anymore."

00:11:25.720 --> 00:11:27.180
Yeah, question.
&gt;&gt; For the three partners.

00:11:27.180 --> 00:11:29.120
&gt;&gt; PARLANTE: Oh, yes. Okay. Thanks for the
question.

00:11:29.120 --> 00:11:34.830
&gt;&gt; Statement with a...
&gt;&gt; PARLANTE: Yeah, so if you are actually

00:11:34.830 --> 00:11:40.890
looking for the period characters, so like
what, say, you know, I don't know. There's

00:11:40.890 --> 00:11:47.880
a dot there. But you were right, it is C.
And you can always put a backslash in and

00:11:47.880 --> 00:11:53.440
that inhibits the specialness of a character.
So, I could look for c.g. You know, I can

00:11:53.440 --> 00:11:59.300
look for c.--"\.l" there. Now, I'm going to
introduce a slight extra for the syntax here

00:11:59.300 --> 00:12:05.399
which Python has, which is--where it's a little
troubling like the backslash, it could be

00:12:05.399 --> 00:12:09.790
interpreted at different levels like maybe
Python or like a Java--or--it might get taken

00:12:09.790 --> 00:12:14.149
out by the language. So, talking too much
on this, I'm just going to say--Python has

00:12:14.149 --> 00:12:19.360
an option called a raw strength where you
put a raw strength where you put a lower case

00:12:19.360 --> 00:12:26.160
R to the left of the leading quote. And what
the lower case army, it says, "Do not do any

00:12:26.160 --> 00:12:31.830
special processing with backslashes. Whatever
I type, just send it through absolutely raw

00:12:31.830 --> 00:12:37.470
and un-interpreted." This feature--I mean,
it's a little bit obscure, but it happens

00:12:37.470 --> 00:12:41.279
to be very useful providing regular expressions
because it frees us from having to worry about

00:12:41.279 --> 00:12:44.950
layers of backslash as possible. So, in fact--even
though I've done my examples so far about

00:12:44.950 --> 00:12:47.610
the R, I'm just going to use the lower case
R for all of my examples from here and out.

00:12:47.610 --> 00:12:53.140
So, I just don't have to think about it. So,
in this case, let's just try it. Yes, so then

00:12:53.140 --> 00:12:57.240
it's able to find this--you know, so it's
matching now. So, that's an L with the dot.

00:12:57.240 --> 00:13:03.720
So that, you know, that will enable to talk
about a dot disposable. All right, so the--where

00:13:03.720 --> 00:13:08.551
we got so far, so it goes left to right, dot
matches any character, and all of the pattern

00:13:08.551 --> 00:13:11.480
has to be matched but the text, you know,
we don't care. You don't have to get all the

00:13:11.480 --> 00:13:19.560
text. So, let me show you some slightly more
scary example. So let's say in my text here

00:13:19.560 --> 00:13:23.670
I've got--you know, there are some text that
I don't care about and I'm going to say, you

00:13:23.670 --> 00:13:31.529
know, ":cat" and then there's more texts.
So let's say I want to pick that part out.

00:13:31.529 --> 00:13:38.920
So, the next sort of regular expression code
I'm going to talk about is "\w." So "\w,"

00:13:38.920 --> 00:13:44.839
which is actually what I have up here, "\w"
matches what you called a word character.

00:13:44.839 --> 00:13:50.791
So that means a letter or a digit and I think
it also includes underbar. So in this case,

00:13:50.791 --> 00:13:58.220
I'm going to say, well, let's say I'm looking
for a colon followed by three-word characters.

00:13:58.220 --> 00:14:09.190
So that's going to work okay. So, now, I could
say--like sort to the "\w," there's "\d" matches

00:14:09.190 --> 00:14:17.579
a digit. So, for example, if I say cat and
I'll say like ":123."

00:14:17.579 --> 00:14:23.519
&gt;&gt; Between the "\w\w\w" and "...."
&gt;&gt; PARLANTE: So, "..."-- it's an excellent

00:14:23.519 --> 00:14:27.839
question. The question is what's there ensuing
 "..." and, you know, three "\w?" The "..." is

00:14:27.839 --> 00:14:33.060
just any character, like, it could be a space,
a colon, and anything. The "\w" matches a

00:14:33.060 --> 00:14:37.870
character so long is it looks like a word
character, like, A through Z, zero through

00:14:37.870 --> 00:14:44.380
nine, underbar. No, so if this was a Unicode
string, the word, it's smarter about being--there

00:14:44.380 --> 00:14:48.339
is a basic notion of an alphabetic character
versus, essentially, punctuation. Oh, yeah,

00:14:48.339 --> 00:14:51.040
question.
&gt;&gt; Zero through nine, is that true, the word

00:14:51.040 --> 00:14:53.140
character?
&gt;&gt; PARLANTE: Yeah, a word character includes

00:14:53.140 --> 00:14:58.540
digits zero through nine. So, I mean, you
know what it's a little bit like is usernames,

00:14:58.540 --> 00:15:06.790
right? You know, blah-vadi-blah 123, you know,
the username. That will show up in the later

00:15:06.790 --> 00:15:14.260
example. Okay. So, digit is little bit similar.
Where is my cat example going? Oh, well, suppose

00:15:14.260 --> 00:15:22.610
we'll do it again. So, if I were looking for,
you know, have blah, you know, ":123xxx,"

00:15:22.610 --> 00:15:27.130
let's see. So I could look for--actually,
here, I'll just look for--I'm just looking

00:15:27.130 --> 00:15:34.930
for three digits in a row. I can write that
as--I'm going to put the r also here. So,

00:15:34.930 --> 00:15:40.089
that pulls out the 123. Now, it happens there's--so
you can see there are sort of these different

00:15:40.089 --> 00:15:44.110
regular expression codes: "\w\w." You know,
they kind of represent sort of common cases.

00:15:44.110 --> 00:15:47.160
I'm not going to show you all of them, but
I'm sure you know the ones that I think are

00:15:47.160 --> 00:15:50.860
the most useful and, you know, ones that kind
of show up in the product are going to be

00:15:50.860 --> 00:15:56.899
later. All right, let's say--last one I'm
going to show here is whitespace. So, supposed

00:15:56.899 --> 00:16:02.790
I'm looking for like this pattern. It's like,
well, I want some digits and they're separated

00:16:02.790 --> 00:16:10.540
by spaces. So the simplest way you do that
is a "\s" represents a whitespace character.

00:16:10.540 --> 00:16:16.660
And the "\s" is smart that it knows about
space, tab, new line, those all count as a

00:16:16.660 --> 00:16:20.230
whitespace character. It knows about the whole
sort of space, the whitespace characters.

00:16:20.230 --> 00:16:23.029
So, hopefully, that will work so that finds
it.

00:16:23.029 --> 00:16:26.820
&gt;&gt; One, two...
&gt;&gt; PARLANTE: Yeah, so look--so the question

00:16:26.820 --> 00:16:30.430
is if you had two spaces. Just hold that thought
for a second because I'm about to--we're about

00:16:30.430 --> 00:16:35.050
to get there. So, so far, I haven't done any
repetition. I've just to have like, you know,

00:16:35.050 --> 00:16:39.820
fix numbers and things. So the--probably,
the most powerful part of regular expressions

00:16:39.820 --> 00:16:46.350
is that there is these modifiers, plus and
star. So plus to the right of something means

00:16:46.350 --> 00:16:51.980
one or more of that, and star means zero or
more. So, we'll have just going to do that

00:16:51.980 --> 00:16:59.010
with my digit example. So the question is,
like, what if I got these three digits--whatever.

00:16:59.010 --> 00:17:03.790
There's just some amount of space in between
them. So the way you would say that in regular

00:17:03.790 --> 00:17:10.520
expression is, like, put a plus to the right
of that "\s." And that means--yeah, one or

00:17:10.520 --> 00:17:14.510
more--that element repeats. There's just one
or more of those. And I'll do it with this

00:17:14.510 --> 00:17:23.790
one as well. So, here, turn there. So now
that matches. So, adding the plus and the

00:17:23.790 --> 00:17:29.600
star, and I'll do a bunch of examples with
these. You know, exactly what we want to start

00:17:29.600 --> 00:17:35.981
matching more complicated patterns. Also,
remember how I was saying how per character

00:17:35.981 --> 00:17:40.020
regular expressions, I think it's like pretty
the densest language that any normal person

00:17:40.020 --> 00:17:43.500
would use. And, like, look at that little--okay,
look at that little bit of code, right? That

00:17:43.500 --> 00:17:47.280
really means something, right? Every character
in the order--I mean, it's all really pretty

00:17:47.280 --> 00:17:50.290
significant. So, it's getting--I was about
to say it's going to get worse. But what I

00:17:50.290 --> 00:17:54.460
meant to say is it's about to get even more
interesting. Whatever a professor uses the

00:17:54.460 --> 00:17:58.340
word interesting, you always know you're in
big trouble. All right, so let me do--I want

00:17:58.340 --> 00:18:04.320
to use those puzzling a little bit. So, let's
say I'm looking for--I've got this random

00:18:04.320 --> 00:18:10.540
text and I'm looking for a colon and then,
you know, let's say, a word character. You

00:18:10.540 --> 00:18:17.270
know, I'll use kitten instead and just more
texts here. Now earlier, I've said, oh, you

00:18:17.270 --> 00:18:20.740
know, I kind of knew how long the word was,
but that was kind of a ridiculous assumption.

00:18:20.740 --> 00:18:26.350
The more typical way to do is would be, let's
say, well, there's a colon and I'll say, "And

00:18:26.350 --> 00:18:33.050
then, there's just some number of word characters."
So, I would write that as "\w+." That's the

00:18:33.050 --> 00:18:36.580
much more typical way, right? Like, you have
the sum, you got quarter, something that sort

00:18:36.580 --> 00:18:39.950
of starts, and then you're like, "Yeah, whatever,"
then just take all the word characters from

00:18:39.950 --> 00:18:45.100
there. So, if I write it that way, then it
will like--it just picks up the kitten part.

00:18:45.100 --> 00:18:49.560
So, that is a--beginning to look a little
more the way these things actually work.

00:18:49.560 --> 00:18:53.400
&gt;&gt; A word character...
&gt;&gt; PARLANTE: Yeah, so the space is not a word

00:18:53.400 --> 00:18:56.299
character. That's what's making a stop there.
So, all right--and actually there a question

00:18:56.299 --> 00:19:01.200
before, like, does it include digit and so
forth? What if there was like "kitten123?"

00:19:01.200 --> 00:19:04.900
That still works. But if it's like "kitten123"
and I--except I have to add a character, like,

00:19:04.900 --> 00:19:09.320
let's say ampersand, then it stops at the
ampersand. So as the thing, so what the plus

00:19:09.320 --> 00:19:16.540
does is it--the plus is greedy. It goes as
far as it can and then it stops. So, they're

00:19:16.540 --> 00:19:21.080
just kind of the pneumonic for regular expression
is it finds the leftmost solution, the first

00:19:21.080 --> 00:19:25.919
one, and the largest solution. So, the plot
until they accepted there's a plus and a star,

00:19:25.919 --> 00:19:34.270
it will just go as far as it can. Yeah, question.
&gt;&gt; So period-plus will take you all the way

00:19:34.270 --> 00:19:36.750
to the end of the line?
&gt;&gt; PARLANTE: Oh, yeah, so the question is

00:19:36.750 --> 00:19:37.750
period-plus would take you--well, it's not
a question. It's actually a suggestion. So,

00:19:37.750 --> 00:19:40.220
I'm going to refer it as question. What if
I said period-plus? And the answer is I've

00:19:40.220 --> 00:19:44.030
said. Like, yeah, it just goes all the way
at the end, right, so period matches dot,

00:19:44.030 --> 00:19:49.440
ampersand, everything, okay, except for [INDISTINCT].
All ready, yeah.

00:19:49.440 --> 00:19:56.640
&gt;&gt; When you say largest, do you mean that
if you say kitten123, 123, you will find a

00:19:56.640 --> 00:19:57.640
whole?]
&gt;&gt; PARLANTE: So, if I say--you mean here if

00:19:57.640 --> 00:20:05.690
I say kitten123, 123? And I'll go back. So,
this is "\w+." Okay. What do you think it's

00:20:05.690 --> 00:20:12.390
going to do? All right, yeah. So it will go
through both 123s, and then it will stop because

00:20:12.390 --> 00:20:16.080
the space is not a word character but digits
zero through nine are word characters. I mean,

00:20:16.080 --> 00:20:19.370
it's made a bit about this of the word "word,"
right? I mean, to a normal person, it just

00:20:19.370 --> 00:20:24.280
like a word character. But compared to, like,
ampersand, it's a word character. All right,

00:20:24.280 --> 00:20:30.860
so one more code I'm going to show, which
I'll just type in here, is backslash uppercase

00:20:30.860 --> 00:20:38.770
S is a non-whitespace character. It's kind
of like the opposite. And I--I'm a little

00:20:38.770 --> 00:20:43.480
saddened who ever designed regular expressions
chose to have uppercase and lowercase mean

00:20:43.480 --> 00:20:47.450
something different because it just makes
a little bit confusing. But backslash upper

00:20:47.450 --> 00:20:53.730
case S is really pretty darned handy. So,
let's say, for example, I knew that it was

00:20:53.730 --> 00:21:04.020
"kitten123&amp;a=123&amp;," you know, yatta, whatever.
It's all this junk and then there's a space.

00:21:04.020 --> 00:21:09.270
And I want to write a regular expression that
picks up all of that and the ease--but I don't

00:21:09.270 --> 00:21:14.030
know. It's not just word characters, you know
what I mean. It includes all sorts of stuff

00:21:14.030 --> 00:21:20.309
but at least there's not spaces in it. And
a common pattern is if I write that as there's

00:21:20.309 --> 00:21:25.070
a colon and then there's just some series
of non-whitespace characters, and then they'll

00:21:25.070 --> 00:21:28.850
just sort of terminate with the first whitespace
character. So that'll--that just catches the

00:21:28.850 --> 00:21:32.440
whole thing even though, like, the Lord knows
what sort of characters in there. So, just

00:21:32.440 --> 00:21:38.010
as a practical manner, that backslash upper
case S is potentially a handy way to catch

00:21:38.010 --> 00:21:42.620
that stuff. Already, so let me show you--so
those are all the--so the so the plus, the

00:21:42.620 --> 00:21:45.730
star, and those backslash codes, those are
the ones I want to build on. Now, let me--so

00:21:45.730 --> 00:21:49.030
far my examples have been like, you know,
a little bit limited. I want to--now, I'm

00:21:49.030 --> 00:21:52.549
going to do an example with e-mails, I mean,
how to build it up and hopefully I'll show

00:21:52.549 --> 00:21:59.289
you pretty practical patterns you can use.
All right, so I'm going to make up some texts

00:21:59.289 --> 00:22:09.169
here. I'll keep the "blah." So, let's say
we are looking for, you know, nick.p@gmail.com

00:22:09.169 --> 00:22:13.490
and then there's more junky text and let me
just add an @ sign just by itself. I'll just

00:22:13.490 --> 00:22:22.960
leave it that for now. All right, so the problem
I want to solve is pulling e-mail. I want

00:22:22.960 --> 00:22:27.139
to imagine. I've got this big body of text
and I want to pull e-mail addresses out of

00:22:27.139 --> 00:22:33.350
it using regular expressions. So, the--I'm
going to try--first I'm going to try to write

00:22:33.350 --> 00:22:39.790
this as "\w+" and then there's an "@" sign
and then there's "\w+." It's kind of, you

00:22:39.790 --> 00:22:47.640
know, plausible (ph) first job (ph) this.
So, if we run that, so what's happened here?

00:22:47.640 --> 00:22:51.210
So what's happened is, well, you know, it
finds--there's the "@" sign. It's the "p,"

00:22:51.210 --> 00:22:56.270
but it can't go further left in that because
the dot does not count as a "\w" character.

00:22:56.270 --> 00:23:01.100
And then likewise, it gets Gmail over here
but then it's compounded by dot. So what I

00:23:01.100 --> 00:23:06.970
want to say with the apparel (ph) is I want
to sort of expand--it's not just word characters,

00:23:06.970 --> 00:23:12.070
really it's word characters plus some other
stuff. So, regular expressions, there's this

00:23:12.070 --> 00:23:19.520
very old syntax for indicating a set of characters
and it's going to use the square brackets.

00:23:19.520 --> 00:23:23.610
So, inside of those square brackets, I can
put "Well, here's the set of characters that

00:23:23.610 --> 00:23:28.240
I'm going to allow here." And actually the
"\w" works inside of the square brackets because

00:23:28.240 --> 00:23:35.260
it's just a common case. So, what I want to
say here is, well, "/w" or let's say dot,

00:23:35.260 --> 00:23:42.240
and then let's say--well, just leave it that.
So, the question is--yes, that's a very natural

00:23:42.240 --> 00:23:45.780
question. That dot--it happens, you don't
have to backslash that one, that it understands

00:23:45.780 --> 00:23:49.610
that the dot inside of the square bracket
is just the dot.

00:23:49.610 --> 00:23:54.401
&gt;&gt; "\w" is included in that?
&gt;&gt; PARLANTE: No, so "\w" word character is

00:23:54.401 --> 00:23:58.980
just A through Z, zero through nine. It just
not--oh I'm sorry, I'm sorry. That, no, that

00:23:58.980 --> 00:24:02.169
dot there means literally a dot. It doesn't
match any character.

00:24:02.169 --> 00:24:04.700
&gt;&gt; Because it's in the square bracket.
&gt;&gt; PARLANTE: Because it's in the square bracket,

00:24:04.700 --> 00:24:07.929
it means literally a dot. I mean, it's--I
mean it's sort of what's going on here. I

00:24:07.929 --> 00:24:10.799
mean, you could do work on your Ph.D. and
the text or something that it's kind of levels

00:24:10.799 --> 00:24:14.660
of quoting. It's kind of what's going on here.
And it's--it is a necessary complexity to

00:24:14.660 --> 00:24:18.420
talk about this kind of thing. Let's all just
see what dot does. All right, so you can see,

00:24:18.420 --> 00:24:24.081
you know, you can sort of see that--so that
picks up its word character and then it stops

00:24:24.081 --> 00:24:29.659
at the space essentially, right? So, it is--it's
not really a dot. I'm sorry. It's not a regular

00:24:29.659 --> 00:24:34.800
expression dot. It's just a regular dot. All
right, so I'm going to fix the other side

00:24:34.800 --> 00:24:38.583
as well. So, I'll put a square bracket over
here and I'll put the dot in there, oops,

00:24:38.583 --> 00:24:45.020
and the plus goes outside, right, I'm saying
that whole set repeats. All right, so that's

00:24:45.020 --> 00:24:50.080
kind of fixed it. So, the square bracket is
probably the most convenient way if there

00:24:50.080 --> 00:24:52.691
are some set of characters that you're looking
for, you know, you kind of build, let's say,

00:24:52.691 --> 00:25:00.710
well, yeah, here's I'm looking for. What if
I had a dot for Nick? I'm sorry, dot, you

00:25:00.710 --> 00:25:04.080
mean, like a he...
&gt;&gt; Text.

00:25:04.080 --> 00:25:09.789
&gt;&gt; PARLANTE: Oh, it would just--it would pick
it up. I mean, we've said, you know, we've

00:25:09.789 --> 00:25:16.600
said to the left of the @ sign just, you know,
as many of these as possible so it'll--now,

00:25:16.600 --> 00:25:21.711
suppose we wanted to say that the first character
can't be a dot, it must be a word character,

00:25:21.711 --> 00:25:31.720
can you think of way in the pattern we could
say that? Yeah, I could have a single backslash.

00:25:31.720 --> 00:25:36.870
I would say there must be a word character
and then it's followed by one or more of the

00:25:36.870 --> 00:25:39.770
thing that includes a dot. That'll be it.
Although, then to be super--I think, really

00:25:39.770 --> 00:25:44.030
hurt (ph) then we should change that one to
a star, right? Then there must be one or more

00:25:44.030 --> 00:25:49.610
character in the zero or more of these patterns.
&gt;&gt; [INDISTINCT] mostly inside the brackets

00:25:49.610 --> 00:25:50.679
the order doesn't matter in the...
&gt;&gt; PARLANTE: Yes, once it--exactly, yes. So

00:25:50.679 --> 00:25:53.440
once it's inside the bracket, the order doesn't
matter or, I mean, try to use the word set,

00:25:53.440 --> 00:25:56.700
it's a set of characters. All right, so let's
try that. Yeah, so then that refines them.

00:25:56.700 --> 00:26:00.950
All right, so anyway, I mean--yes, it is a
sort of a bottomless topic. I mean, you know,

00:26:00.950 --> 00:26:07.210
there's--but, I mean, hopefully, I'll show
you stuff that are useful. All right, so I've

00:26:07.210 --> 00:26:14.059
got my e-mails example, so that's the first
thing. So that's just using group, right?

00:26:14.059 --> 00:26:19.740
All I've been doing there is just using group.
So now, what I'd like to show you is I'm going

00:26:19.740 --> 00:26:24.970
to stop using my find function. I'm going
to start doing this raw here. And what I'd

00:26:24.970 --> 00:26:34.799
like to do is I want to imagine that I want
to pick out the username and the hostname

00:26:34.799 --> 00:26:42.620
separately. I want to sort of pick those out.
And so, just go back here. I'll just change

00:26:42.620 --> 00:26:48.452
this to "m=re.search" so I'm just doing it
manually again. And you can do this--I'm going

00:26:48.452 --> 00:26:57.770
to change this back to just the regular way
here. By putting parenthesis in the regular

00:26:57.770 --> 00:27:03.330
expression around the parts that you care
about. Now, the way I'm doing it here, the

00:27:03.330 --> 00:27:07.790
parentheses are not changing what it's going
to match. I'm just kind of putting in those

00:27:07.790 --> 00:27:12.590
mark up of saying, "Well, these are the two
parts that I care about." And here I'll get

00:27:12.590 --> 00:27:18.039
rid of this dot. So, if I do that, right,
so I put parenthesis around the part that

00:27:18.039 --> 00:27:22.100
matches the username and parenthesis around
the part that matches the host and the @ sign

00:27:22.100 --> 00:27:25.110
I've just--I've done, I don't care about.
So, now, I've done this. If we look at "m,"

00:27:25.110 --> 00:27:30.850
it's a match object. If I say, "m.group,"
it's the whole thing, like, just like we've

00:27:30.850 --> 00:27:36.179
always been doing. But there's also a form
of the group where you passed at a number.

00:27:36.179 --> 00:27:43.330
So, if I say, "m.group(1)," that's now just
the username part. And the "1" refers to the

00:27:43.330 --> 00:27:49.210
first set of parentheses. So if you count
the parentheses--and it goes by the left parenthesis

00:27:49.210 --> 00:27:54.400
because you could actually nest them. So the
"group(1)" refers to the leftmost parenthesis,

00:27:54.400 --> 00:28:01.360
which if you look up here, there's, like,
yeah, that's that guy. And then, "m.group"--oops,

00:28:01.360 --> 00:28:09.970
you can just guess, "group(2)," that's now
the hostname. So, a more--the way this is

00:28:09.970 --> 00:28:12.731
going to work for, you know, some problems
or regular expressions is all the times you'll

00:28:12.731 --> 00:28:16.080
write a regular expression for the thing you're
kind of looking for, right? Well, I'm looking

00:28:16.080 --> 00:28:20.510
for a URL, or an I.P. address, or something,
and then you'll maybe put parentheses and

00:28:20.510 --> 00:28:25.250
then say, "And here's the part that I want
to extract." Then you'll call "re.search,"

00:28:25.250 --> 00:28:28.700
you'll get this match object and then you'll
use "group(1)" and "group(2)," whatever, to

00:28:28.700 --> 00:28:31.900
just kind of--it's already, you know, parsed
it for you. You'll just pull out the parts

00:28:31.900 --> 00:28:34.590
that you want as text and then process from
there. Yeah, question.

00:28:34.590 --> 00:28:42.799
&gt;&gt; If I put a plus or a star after one of
these [INDISTINCT] the first parenthesis and

00:28:42.799 --> 00:28:45.809
it matches that twice, is that "group(1)"
and then "group(2)" or is it still a group...?

00:28:45.809 --> 00:28:51.200
&gt;&gt; PARLANTE: Yeah, so the question is if there's
a plus after the parenthesis, you know, does

00:28:51.200 --> 00:28:54.559
that change how the group number works? The
answer is no. The group numbering is based

00:28:54.559 --> 00:28:59.440
on just statically looking at the pattern
as an unchanging thing and just counting the

00:28:59.440 --> 00:29:05.919
left parenthesis from--going from left to
right. So that is the shortest answer I can

00:29:05.919 --> 00:29:17.299
give there. Already, so I've got--I want to--so
"re.search" is my second favorite Python regular

00:29:17.299 --> 00:29:27.840
expression, regular function. My absolute
favorite one--actually, let me make my data

00:29:27.840 --> 00:29:35.409
a little more complicated here. I guess I'll
also add a "foo@bar." My absolute favorite

00:29:35.409 --> 00:29:46.110
regular expression function is called "findall."
So, I'll just say "findall" here. And what

00:29:46.110 --> 00:29:51.390
"findall" is going to do is I've just still
got a pattern, and now I've just changed my

00:29:51.390 --> 00:29:56.940
text to--you know, I put a second e-mail address
in there. What "findall" does is it just takes

00:29:56.940 --> 00:30:01.230
the pattern and rather than just stopping
at the first match, it just continues and

00:30:01.230 --> 00:30:06.510
it just finds all of the matches and it returns
them to you--it returns to you essentially

00:30:06.510 --> 00:30:13.400
the ".group," right, the whole text just in
the Python list of other strings. So, for

00:30:13.400 --> 00:30:18.610
example, we talked about for a file how you
could just say "f.read" to get the entire

00:30:18.610 --> 00:30:24.000
text is one string. So a pattern--I was in
joy because it just saves me so much work

00:30:24.000 --> 00:30:28.130
is I just call "re."--I just call "f.read"
and I pass that in as the second argument

00:30:28.130 --> 00:30:33.419
to a "findall." I just feed the entire file
into an "re.findall." I have a pattern, I

00:30:33.419 --> 00:30:37.090
just let it ripped through the entire text,
skip new lines, whatever, all that stuff it

00:30:37.090 --> 00:30:41.500
just handles, and it just pulls out the things
I want and just returns them to me as a Python

00:30:41.500 --> 00:30:44.539
list. And then, I can--you can write a for
loop, you know, stuff we're doing yesterday.

00:30:44.539 --> 00:30:51.320
Now, you can just process this list. So that
is--that's really how you use this stuff.

00:30:51.320 --> 00:30:56.270
So, in this case--so notice I took the parentheses
out. So I just left this as a simple pattern.

00:30:56.270 --> 00:31:00.500
So I just got, you know, I just got the system
matches (ph). There's this one other variation

00:31:00.500 --> 00:31:09.020
I can do here. What do you supposed is going
to happen if I put the parentheses back in?

00:31:09.020 --> 00:31:13.799
I'm, like, well, this is, you know, it's not
really--it's a pattern but it has this grouping

00:31:13.799 --> 00:31:20.279
in it. And, yeah, we have tuples. What it's
going to do is if there are parentheses in

00:31:20.279 --> 00:31:25.360
there, instead of just returning the whole
match, it says, "Oh, well, there's two plans.

00:31:25.360 --> 00:31:30.091
I'm going to return tuples length, too." So
each tuple represents a single match and then

00:31:30.091 --> 00:31:35.730
the tuple just has the groups in there. So,
that--yeah, you can see where this can be

00:31:35.730 --> 00:31:38.860
pretty handy. If you got some big file, you
just want to kind of--there are some part

00:31:38.860 --> 00:31:42.289
about you care about, you just want to rip
it out as lazily as possible, so "re.findall."

00:31:42.289 --> 00:31:44.730
&gt;&gt; You'll lose the format.
&gt;&gt; PARLANTE: Excuse me?

00:31:44.730 --> 00:31:47.221
&gt;&gt; You'll lose the format.
&gt;&gt; PARLANTE: Yeah, I mean, I would say--so

00:31:47.221 --> 00:31:51.460
let's say you lose the format. Let's say,
well, the regular expression is narrowing.

00:31:51.460 --> 00:31:55.020
You get to say what you want to keep. And
so, if you want to keep more, you know, write

00:31:55.020 --> 00:32:00.740
the regular expression bigger, you know, to
keep one. All right, so that's, you know,

00:32:00.740 --> 00:32:04.809
not hard to imagine how we're--it's going
to be easy for you to work that in to--doing

00:32:04.809 --> 00:32:14.400
stuff later on. So, I'll just mention, there
are some optional arguments that you can add

00:32:14.400 --> 00:32:19.921
sort of hear as a third option to the regular
expression. And what I'm going to actually

00:32:19.921 --> 00:32:26.029
do, I'm going to do a DIR on re. So that's
the re module. I can say, "Oh, yeah, hey,

00:32:26.029 --> 00:32:30.100
what are these symbols in here?" So these
are some constants. So, if you add the constant,

00:32:30.100 --> 00:32:37.100
"IGNORECASE," to you--this works on ".search"
or ".findall." That means that it'll consider

00:32:37.100 --> 00:32:42.789
upper and lowercase the same. So a lowercase
isle matches an uppercase isle and vice-versa.

00:32:42.789 --> 00:32:51.390
You can do the ".all." I had said that the
dot matches any character except for new line

00:32:51.390 --> 00:32:55.580
and that's kind of historical thing because
the processing tended to go line by line.

00:32:55.580 --> 00:33:00.830
If you add the "DOTALL" flag, then the dot
will match new line as well. And so, you could--because

00:33:00.830 --> 00:33:05.190
right now, if you use dot, you're pattern
can't expand more than one line. Although,

00:33:05.190 --> 00:33:08.659
if you use "\s" where you think there's a
new line, that'll expand the line but the

00:33:08.659 --> 00:33:12.549
dot will not go over one. So, if you mean--if
you add "DOTALL," you can turn off that behavior

00:33:12.549 --> 00:33:16.460
and that will just truly match anything. So,
if you were to say "DOTSTAR" with nothing

00:33:16.460 --> 00:33:22.630
else, it would just go to the end of the file.
So there's more--I think the most common ones

00:33:22.630 --> 00:33:25.640
to use there.
&gt;&gt; [INDISTINCT] at the end of, like, [INDISTINCT].

00:33:25.640 --> 00:33:28.669
&gt;&gt; PARLANTE: Yeah, so let me--I'll give you
an example. So the way you would use those

00:33:28.669 --> 00:33:35.261
constants is it says a third argument. So
you would say, "re.IGNORECASE" or whatever.

00:33:35.261 --> 00:33:41.350
That's the last argument there. All right,
and so the, you know, a couple--the handouts

00:33:41.350 --> 00:33:46.640
for today, the first one--if you didn't get
one, you can get one in a second. The, you

00:33:46.640 --> 00:33:49.960
know, there's a nice, you know, an explanation
of regular expressions and it shows the syntax

00:33:49.960 --> 00:33:54.200
and, you know, a lot of kind of stuff there
or whatever we're doing here. All right, so

00:33:54.200 --> 00:34:03.000
I think we're ready for an exercise. So the
exercises today are going to be a little bigger.

00:34:03.000 --> 00:34:06.650
There's three of them I'd like to do today
and, you know, kind of incorporate all those

00:34:06.650 --> 00:34:17.249
sort of stuff. So let me demo this first one.
So, this fist one is going to involve a brief

00:34:17.249 --> 00:34:22.589
4A (ph) into a little understood part of the
government called the Social Security Administration.

00:34:22.589 --> 00:34:27.649
Now, the Social Security Administration in
my life experience is in-charge of putting

00:34:27.649 --> 00:34:32.389
certain fields on everyone's paycheck that
no normal person understands and it just caused

00:34:32.389 --> 00:34:35.700
you [INDISTINCT] just not that was going on,
but they do this other thing. If you do a

00:34:35.700 --> 00:34:39.990
Google search for Social Security Administration
baby names, they do this thing where they

00:34:39.990 --> 00:34:46.709
keep track of what the popular baby names
are for babies born in that year. And they'd

00:34:46.709 --> 00:34:51.690
been doing that actually for a hundred years.
So you could look at 1900, 1950, whatever,

00:34:51.690 --> 00:34:56.079
you can just see--it turns out for baby names,
there's sort of a--there's a popularity of

00:34:56.079 --> 00:35:00.289
it. There are sort of names kind of I have
in the flow (ph). So, I look at this and I

00:35:00.289 --> 00:35:03.859
see assignment idea. So, let's go to--oh,
I don't know, 1980. I'm not even going to

00:35:03.859 --> 00:35:11.641
try and think about when you guys were all
born. Do you know what I'm saying? And let's

00:35:11.641 --> 00:35:18.790
just go with, like, I don't know the top thousand.
So we get those, like--you'll look at this

00:35:18.790 --> 00:35:23.170
and you're just thinking like, "tr," "td,"
that kind of thing, you know, good thinking.

00:35:23.170 --> 00:35:28.109
All right, so, here's just for 1980. The list
of baby names and what does this is saying

00:35:28.109 --> 00:35:34.519
is that for boy children, Michael was the
most popular name. And then, next most popular

00:35:34.519 --> 00:35:38.299
was Christopher, Jason, David, and so on.
And over here, we have Jennifer, number one;

00:35:38.299 --> 00:35:44.609
Amanda, number two; and it just goes down
to, like, you know, here we have, you know,

00:35:44.609 --> 00:35:51.119
Bobbie, Emil, Jermain, Kraig with the K, down
to the, you know, the less popular names.

00:35:51.119 --> 00:35:59.589
All right, so what I would like to do--going
back to Python here, let's see what I have.

00:35:59.589 --> 00:36:06.140
Okay. So I'm going to go into "day2" here,
and there's a directory, baby names. So, if

00:36:06.140 --> 00:36:12.469
I look inside here, let me look at "baby1990,"
I've pulled this sort of--I just sort of copied

00:36:12.469 --> 00:36:16.109
and cleaned up just a tiny bit the text from
Social Security Administration site. I put

00:36:16.109 --> 00:36:20.559
this very [INDISTINCT]. Okay, well, there's
some partly written CSS and whatever. And

00:36:20.559 --> 00:36:26.849
then eventually, there's--here's the "h1"
and then here's a table blah, blah, blah,

00:36:26.849 --> 00:36:32.650
and at some point it's going to say--all right,
here we go. So here's the "h3." This is popularity

00:36:32.650 --> 00:36:41.859
in 1990, or as I like to think of it is popularity
in "\d\d\d." And then, there's some whatever

00:36:41.859 --> 00:36:47.170
junk you want to skip and then here's a "tr."
And then here, there's the "tr." And if you

00:36:47.170 --> 00:36:51.519
don't know HTML but whatever, that's the HTML
for that first row. So it says, "tr," "td,"

00:36:51.519 --> 00:36:56.209
and then there's the number one. And then
there's more "td" stuff and there's Michael,

00:36:56.209 --> 00:37:00.779
and there's Jessica, and then here's row two,
and so on. And it just goes on, like, there's

00:37:00.779 --> 00:37:06.920
all the data. It's beginning to look like
an actual problem. All right, so, the first

00:37:06.920 --> 00:37:13.529
thing what I want your baby names program
to do is given a file, like, "baby1990.html"

00:37:13.529 --> 00:37:18.450
and I'm going to pipe this into more. What
I want you to do is I want you to rip through

00:37:18.450 --> 00:37:22.509
that entire file. I want you to figure out
what year it represents. I want you to pull

00:37:22.509 --> 00:37:27.279
out all the names and all the ranks. I want
you to organize it so that you can--then produce

00:37:27.279 --> 00:37:32.482
a printout that's just in alphabetical ordered
by name. So just I've shown here. So you say--so

00:37:32.482 --> 00:37:37.400
the first--first you print the year and then
I want to see Aaron 34, Abbey 42, and so on.

00:37:37.400 --> 00:37:42.959
So you're just show an alphabetical list,
here's all the names are. So that will get

00:37:42.959 --> 00:37:45.410
us through the...
&gt;&gt; Combine male and female?

00:37:45.410 --> 00:37:48.829
&gt;&gt; PARLANTE: Yeah, so what's going to happen
is there's a strange case but sometimes a

00:37:48.829 --> 00:37:52.630
name will appear as both male and female.
And I'm making any distinction male from female.

00:37:52.630 --> 00:37:57.729
So in that case, I want you to give it the
more popular, essentially the smaller number,

00:37:57.729 --> 00:38:05.579
whatever the smaller number is, all right?
So, the--oh, let me talk--I'm going to go

00:38:05.579 --> 00:38:12.569
back to Python for just a second. There's
something I mentioned I think maybe very briefly

00:38:12.569 --> 00:38:18.019
yesterday but it's about to come up, which
is we did file opening, right? So, "f=open(filename,"

00:38:18.019 --> 00:38:25.660
so I'll remind you, if you want to write a
file, if you want to do it for writing, then

00:38:25.660 --> 00:38:31.029
for that second argument you pass a "w." So,
yesterday we just did "r." We just read the

00:38:31.029 --> 00:38:37.319
file, so that's fine. So, you put a "w" there
for writing. And in that case, then probably

00:38:37.319 --> 00:38:42.319
the simplest way to write to the file is then
it has a ".write" and then you could just

00:38:42.319 --> 00:38:46.703
have, you know, whatever kind of text you
want in there. And so, you've got to be careful,

00:38:46.703 --> 00:38:49.990
you can zero out of file here but it'll write
that text. And so, this is [INDISTINCT] as

00:38:49.990 --> 00:38:56.890
well. That's about to come up. All right,
so that is--so part A is I want you to just

00:38:56.890 --> 00:39:01.469
pull out all the names, you know, use a regular
expression, findall, maybe a dictionary, I

00:39:01.469 --> 00:39:12.599
mean, just total regular work. So for part
B, what I'm going to do is there's an option

00:39:12.599 --> 00:39:22.789
called "--summaryfile." And I'm going to run
this on as star or I'm going to say "baby*.html."

00:39:22.789 --> 00:39:30.069
In that case, I want you to produce no output.
What did that just do? When the "--summaryfile"

00:39:30.069 --> 00:39:34.740
option is given, what I want you to do--oh,
notice in this case, I ran it on "baby*."

00:39:34.740 --> 00:39:39.299
So I ran it on all of the baby files, right?
So the shell just expands out, so in that

00:39:39.299 --> 00:39:43.640
case "rv" is going to be all of them. If the
"--summaryfile" like I've just given, what

00:39:43.640 --> 00:39:47.739
I want you to do is for each file I want you
to read it and I want you to create a new

00:39:47.739 --> 00:39:53.499
file with the same filename but ending in
".summary," and then I want you to take that

00:39:53.499 --> 00:39:56.450
output that we were printing to the screen
earlier and I want you to write it to that

00:39:56.450 --> 00:40:00.160
file. Now, there's a little bit of a trick
here which is I've shown. So, for example,

00:40:00.160 --> 00:40:03.559
when you have a low level function, you're
not necessarily want it print it to stand

00:40:03.559 --> 00:40:06.801
it out directly. You want to have a function,
like, given the file, returns to you to say

00:40:06.801 --> 00:40:10.359
a Python list or a dictionary or something.
And then the code that got that data structure

00:40:10.359 --> 00:40:14.779
can choose what to do with it. It can either
print it to stand it out, or it could print

00:40:14.779 --> 00:40:18.949
your file. So you've got that [INDISTINCT].
I'm sorry. Certainly that technique will come

00:40:18.949 --> 00:40:22.799
up tying to solve this. All right, so once
you've got that, then you can do something

00:40:22.799 --> 00:40:31.049
kind of neat. So, when I got these ".summaryfiles"
and what's happened is because I've done them

00:40:31.049 --> 00:40:36.420
over a decade, you can sort of see patterns,
right? So this is going an increasing order

00:40:36.420 --> 00:40:42.529
by year. So my name--the "Nick" format list
was, like, not looking so good and it's getting

00:40:42.529 --> 00:40:48.959
worse. Now, well, there's a lot of interesting
data in here. So you can, you know, interesting

00:40:48.959 --> 00:40:54.799
data makes for fun as what I'm trying to think.
Here's probably the funniest part of this

00:40:54.799 --> 00:41:02.109
thing. There's a "Trinity" and the question
is, "In what year did the movie the Matrix

00:41:02.109 --> 00:41:09.640
come out?" And, yeah, there's another few
things that you could do here. So, like, well,

00:41:09.640 --> 00:41:14.609
maybe the Matrix was reacting to a social
phenomenon, or it's the other way around.

00:41:14.609 --> 00:41:19.180
It's all very complicated.
&gt;&gt; PARLANTE: Yeah, yeah, [INDISTINCT] there's

00:41:19.180 --> 00:41:23.009
a New York Times Magazine [INDISTINCT]. Anyway,
it just turns out this entire topic of baby

00:41:23.009 --> 00:41:26.329
name popularity is sort of very interesting
and at least now you're--and you get to do

00:41:26.329 --> 00:41:30.839
the, like, the needy goody work of actually
pointing out that data. All right, so here's

00:41:30.839 --> 00:41:38.839
what I'd like you to do, work on this and
then--that will get us to--and then have lunch

00:41:38.839 --> 00:41:45.859
and I'd like you back here at, let's say,
12:45, all right? So a little bit of coding,

00:41:45.859 --> 00:41:49.109
a little bit of lunch, and then back here,
all right, go.

